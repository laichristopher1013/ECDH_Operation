#y^2 = x^3 + ax + b
#ECC (elliptic curve operation)
    #check (check p is on the ecc or not) 
    #findinverse (find the inverse of the given point)
    #findcoord (find the coordinates of giving x on the curve)
    #findN (find the quantity of all the points thats on the curve)
    #findn (find the order of the given generated point)
    #add (modadd) 
    #mul (montgomary ladder) 

class ECC:
    #to initialize variable
    def __init__(self, a, b, p):
        self.zero = None
        self.a = a
        self.b = b
        self.p = p

    #to check the point is on the curve or not
    def check(self, p):
        #if point = point at infinity 
        if p == self.zero:
            return True

        #unpack the point
        x, y = p

        #to check the point is out of range or not & to check the point is on the curve or not
        if not (0 <= x < self.p and 0 <= y < self.p) or \
        not (x**3 + (self.a * x) + self.b - y**2) % self.p == 0:
            raise ValueError("Invalid point")
        return True

    #find the inverse of the given point p
    def findinverse(self, p):
        self.check(p)
        x, y = p
        return(x, -y % self.p)

    #find the coordinates of given x
    def findcoord(self, x):
        # to check x is out of range or not
        if x < self.p:
            #to transform the ecc equation in order to make find y more clearer and easier
            n = (x**3 + (self.a * x) + self.b) % self.p

            #to brute force the y to check is there any y can match the given x that conform the ecc equation 
            for i in range(0, self.p):
                if i**2 % self.p == n:
                    return((x, i), (x, -i % self.p))
            raise ValueError("Not found")
        else:
            raise ValueError("Out of range")

    #find the total points that can appear on the ecc that generated by the given variable
    def findN(self): 
        #the 1 point means the point at infinity 
        count = 1 

        #to brute force in order to find the total point 
        for x in range(self.p):
            try:
                p1, p2 = self.findcoord(x)
                #if given x produce 2 same points + 1
                if p1 == p2:
                    count += 1
                #if given x produce 2 different points + 2
                else:
                    count += 2
            except Exception:
                pass
        return count

    #find the total points that can generated by the given point g
    def findn(self, g): 
        self.check(g)
        #because n can only be <= N so brute force it to see what's the n
        for i in range(1, self.findN() + 1):
            #n will always be a cycle so when n reach infinite point it means n is found
            #to keep letting g adding it self until it reach infinite point
            if self.mul(g, i) == self.zero:
                return i
        raise ValueError("Invalid order") 

    #ecc addition
    def add(self, p1, p2):
        self.check(p1)
        self.check(p2)
        #to check p1 / p2 is infinite point or not
        if p1 == self.zero:
            return p2
        elif p2 == self.zero:
            return p1

        x1, y1 = p1
        x2, y2 = p2
        
        #coordinates are each other inverse 
        if x1 == x2 and (y1 + y2) % self.p == 0:
            return self.zero
        #coordinates are the same
        elif (x1, y1) == (x2, y2):
            m = ((x1**2 * 3 + self.a) * pow((y1 * 2), -1, self.p)) % self.p
        #coordinates are different
        else:
            m = ((y1 - y2) * pow((x1 - x2), -1, self.p)) % self.p

        #the result of the 2 coordinates adding together 
        x3 = (m**2 - (x1 + x2)) % self.p
        y3 = (m * (x1 - x3) - y1) % self.p

        return (x3, y3)

    #ecc multiplication
    def mul(self, g, n): 
        self.check(g)
        #montgomery ladder
        r0 = self.zero
        r1 = g

        for i in bin(n)[2:]:
            if i == "1":
                r0 = self.add(r0, r1)
                r1 = self.add(r1, r1)
            else:
                r1 = self.add(r1, r0)
                r0 = self.add(r0, r0)
        
        return r0

#example
if __name__ == "__main__":
    g = (5, 1) 
    n = 5
    a, b, p = 2, 2, 17 
    x, y = g
    ecc = ECC(a=a, b=b, p=p) 
    print("-------------------------------------------\n") 
    print(f"ECC Curve: y^2 = x^3 + {a}x + {b} mod({p})")
    print(f"G: {g}\n" )
    print(f"G Inverse: {ecc.findinverse(g)}") 
    print(f"Coordinates x = {x}: {ecc.findcoord(x)}") 
    print(f"N: {ecc.findN()}") 
    print(f"n: {ecc.findn(g)}") 
    print(f"h: {ecc.findN()/ecc.findn(g)}")
    print(f"{n}G: {ecc.mul(g, n)}") 
    print("\n-------------------------------------------") 
